<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>UNIGAME</title>
  <style>
    :root {
      /* Mobile-optimized counts for better performance */
      --star-count-far: 300;
      --star-count-near: 150;
      --asteroid-count: 8;
      --shooting-star-chance: 0.002;
      --nebula-opacity: 0.2;
      --logo-color: #00f0ff;
      --logo-accent: #ff66cc;
      --parallax-star-count: 50;
      --particle-count: 15;
      --cosmic-purple: #A855F7;
      --cosmic-blue: #06B6D4;
      --cosmic-pink: #F472B6;
      --cosmic-gold: #FBBF24;
      --aurora-green: #34D399;
      --deep-space: #0f172a;
      --toon-orange: #FB923C;
      --toon-red: #F87171;
      --toon-yellow: #FDE047;
      --toon-mint: #6EE7B7;
    }

    /* Mobile-specific optimizations */
    @media (max-width: 768px) {
      :root {
        --star-count-far: 150;
        --star-count-near: 75;
        --asteroid-count: 4;
        --parallax-star-count: 25;
        --particle-count: 8;
        --shooting-star-chance: 0.001;
      }
    }

    @media (max-width: 480px) {
      :root {
        --star-count-far: 100;
        --star-count-near: 50;
        --asteroid-count: 3;
        --parallax-star-count: 15;
        --particle-count: 5;
        --shooting-star-chance: 0.0005;
      }
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a0f2e 0%, #16213e 25%, #0f1419 50%, #1a0f2e 75%, #16213e 100%);
      background-size: 400% 400%;
      animation: gradientShift 20s ease infinite;
      font-family: 'Comic Sans MS', 'Trebuchet MS', cursive, sans-serif;
      color: white;
      /* Performance optimizations */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      will-change: background-position;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Reduce motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
      html, body {
        animation: none;
      }
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ─────────── canvases ─────────── */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      /* Performance optimizations */
      will-change: transform;
    }
    /* farthest stars behind everything (lowest index) */
    #canvas-far       { z-index: 0; }
    /* nearer stars on top of far stars */
    #canvas-near      { z-index: 1; }
    /* asteroids on top of near stars */
    #canvas-asteroids { z-index: 2; }
    /* interactive particles canvas */
    #canvas-particles { z-index: 2.5; }

    /* ─────────── enhanced cosmic background ─────────── */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(255, 105, 180, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(30, 144, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 60% 70%, rgba(255, 215, 0, 0.08) 0%, transparent 40%);
      z-index: -1;
      animation: cosmicShift 25s infinite alternate ease-in-out;
    }

    @keyframes cosmicShift {
      0% { 
        background: 
          radial-gradient(circle at 20% 80%, rgba(255, 105, 180, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 40% 40%, rgba(30, 144, 255, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 60% 70%, rgba(255, 215, 0, 0.08) 0%, transparent 40%);
      }
      50% { 
        background: 
          radial-gradient(circle at 70% 30%, rgba(255, 105, 180, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 30% 70%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(30, 144, 255, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.08) 0%, transparent 40%);
      }
      100% { 
        background: 
          radial-gradient(circle at 80% 20%, rgba(255, 105, 180, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 20% 80%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
          radial-gradient(circle at 60% 60%, rgba(30, 144, 255, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 30%, rgba(255, 215, 0, 0.08) 0%, transparent 40%);
      }
    }

    /* ─────────── parallax stars ─────────── */
    .stars-parallax {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      perspective: 800px;
      overflow: hidden;
      pointer-events: none;
      z-index: 3; /* above all canvases, below nebula */
    }
    .star-parallax {
      --size: calc(1px + (3 * var(--rand)));
      width: var(--size);
      height: var(--size);
      background: white;
      border-radius: 50%;
      position: absolute;
      top: var(--y);
      left: var(--x);
      transform: translate3d(-50%, -50%, var(--z));
      animation: twinkle 4s infinite alternate ease-in-out;
      will-change: transform, opacity;
      opacity: var(--rand-alpha);
    }
    @keyframes twinkle {
      from { opacity: 0.3; }
      to   { opacity: 1.0; }
    }

    /* ─────────── nebula overlay ─────────── */
    .nebula {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(
          circle at 30% 30%,
          rgba(70,10,80,var(--nebula-opacity)),
          rgba(11,13,23,0) 70%
        ),
        radial-gradient(
          circle at 70% 70%,
          rgba(10,30,60,var(--nebula-opacity)),
          rgba(11,13,23,0) 65%
        );
      mix-blend-mode: overlay;
      pointer-events: none;
      animation: nebulaMove 30s infinite alternate ease-in-out;
      z-index: 4; /* above parallax stars */
    }
    @keyframes nebulaMove {
      0%   { transform: translate(-10%, -10%) scale(1); }
      100% { transform: translate(10%, 10%) scale(1.05); }
    }

    /* ─────────── toon-style logo (topmost) ─────────── */
    .logo-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      perspective: 1000px;
      width: 600px;
      height: 120px;
      pointer-events: none;
      z-index: 5; /* highest index */
      text-align: center;
    }
    .logo {
      font-size: 100px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      background: linear-gradient(45deg, 
        #ff6b9d, #c44569, #f8b500, #00d2ff, #3742fa, #ff6b9d
      );
      background-size: 300% 300%;
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      transform-style: preserve-3d;
      transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      user-select: none;
      pointer-events: auto;
      position: relative;
      line-height: 1;
      animation: 
        logoGlow 4s ease-in-out infinite alternate,
        rainbowShift 10s linear infinite,
        bounce 6s ease-in-out infinite;
      cursor: pointer;
      text-shadow: 
        0 0 30px rgba(255, 107, 157, 0.8),
        0 0 60px rgba(255, 107, 157, 0.6),
        0 0 90px rgba(255, 107, 157, 0.4);
      /* Performance optimizations */
      will-change: transform;
    }
    
    .logo::before {
      content: 'Unigame';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, 
        rgba(255, 255, 255, 0.9), 
        rgba(255, 255, 255, 0.1)
      );
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: blur(4px);
      animation: shimmer 3s linear infinite;
      z-index: -1;
    }

    .logo:hover {
      transform: scale(1.05) rotateY(5deg);
    }
    
    @keyframes logoGlow {
      0% { 
        filter: brightness(1) saturate(1.2);
        text-shadow: 
          0 0 30px rgba(255, 107, 157, 0.8),
          0 0 60px rgba(255, 107, 157, 0.6);
      }
      100% { 
        filter: brightness(1.3) saturate(1.5);
        text-shadow: 
          0 0 40px rgba(255, 107, 157, 1),
          0 0 80px rgba(255, 107, 157, 0.8),
          0 0 120px rgba(255, 107, 157, 0.6);
      }
    }

    @keyframes rainbowShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-8px); }
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateX(100%); opacity: 0; }
    }
    
    /* ─────────── responsive design ─────────── */
    @media (max-width: 768px) {
      .logo {
        font-size: 60px;
        animation-duration: 6s, 12s, 8s;
      }
      .logo-wrapper {
        width: 400px;
        height: 80px;
      }
      /* Reduce animation intensity on mobile */
      .logo:hover {
        transform: scale(1.02) rotateY(2deg);
      }
    }
    
    @media (max-width: 480px) {
      .logo {
        font-size: 45px;
        letter-spacing: 0.1em;
      }
      .logo-wrapper {
        width: 300px;
        height: 60px;
      }
      /* Minimal animations on small screens */
      .logo:hover {
        transform: scale(1.01);
      }
    }
    
    /* Performance optimizations for reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .logo:hover { transform: scale(1.02); }
      .logo, .logo::before { 
        animation: none; 
      }
      .star-parallax {
        animation: none;
      }
    }
  </style>
</head>
<body>
  <!-- Canvases in DOM order don’t matter once z‐index is set -->
  <canvas id="canvas-far"></canvas>
  <canvas id="canvas-near"></canvas>
  <canvas id="canvas-asteroids"></canvas>

  <!-- Parallax star container -->
  <div class="stars-parallax" id="stars-layer"></div>

  <!-- Nebula overlay sits above parallax stars -->
  <div class="nebula"></div>

  <!-- Interactive particles canvas -->
  <canvas id="canvas-particles"></canvas>

  <!-- Logo is the topmost element -->
  <div class="logo-wrapper">
    <div class="logo" id="logo">Unigame</div>
  </div>

  <script>
    /* ─── your existing JavaScript (no changes needed here, aside from layering) ─── */
    const canvasFar = document.getElementById('canvas-far');
    const canvasNear = document.getElementById('canvas-near');
    const canvasAst = document.getElementById('canvas-asteroids');
    const ctxFar = canvasFar.getContext('2d');
    const ctxNear = canvasNear.getContext('2d');
    const ctxAst = canvasAst.getContext('2d');

    let starsFar = [], starsNear = [], asteroids = [], shootingStars = [];

    function resizeCanvases() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      [canvasFar, canvasNear, canvasAst].forEach(c => {
        c.width = w;
        c.height = h;
      });
    }
    window.addEventListener('resize', resizeCanvases);
    resizeCanvases();

    class Star {
      constructor(far = true) {
        this.far = far;
        this.reset();
      }
      reset() {
        const w = canvasFar.width;
        const h = canvasFar.height;
        this.x = Math.random() * w;
        this.y = Math.random() * h;
        this.z = this.far ? Math.random() * w : Math.random() * (w / 2);
        this.speed = this.far ? 0.2 : 0.8;
      }
      update() {
        this.z -= this.speed;
        if (this.z <= 0) this.reset();
      }
      draw(ctx) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        const f = 200 / (this.far ? this.z : this.z + 0.1);
        const px = (this.x - w / 2) * f + w / 2;
        const py = (this.y - h / 2) * f + h / 2;
        const r = this.far
          ? (1 - this.z / w) * 1.5
          : (1 - this.z / (w / 2)) * 2.5;
        if (px < 0 || px > w || py < 0 || py > h) return;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${this.far
          ? (1 - this.z / w) * 0.7
          : (1 - this.z / (w / 2)) * 0.9
        })`;
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Asteroid {
      constructor() { this.reset(); }
      reset() {
        const w = canvasAst.width;
        const h = canvasAst.height;
        this.x = Math.random() * w;
        this.y = Math.random() * h;
        this.z = Math.random() * w;
        this.speed = 0.3 + Math.random() * 0.4;
        this.size = 15 + Math.random() * 25;
        this.angle = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.02;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.bobSpeed = 0.01 + Math.random() * 0.01;
        
        // Toon-style colors
        this.colors = [
          '#FF6B9D', '#C44569', '#F8B500', '#00D2FF', 
          '#3742FA', '#2ED573', '#FF3838', '#FF9F43'
        ];
        this.primaryColor = this.colors[Math.floor(Math.random() * this.colors.length)];
        this.secondaryColor = this.colors[Math.floor(Math.random() * this.colors.length)];
        
        // Generate toon-style shape with more variation
        this.shape = [];
        const verts = 6 + Math.floor(Math.random() * 3);
        for (let i = 0; i < verts; i++) {
          const a = (i / verts) * Math.PI * 2;
          const rad = this.size * (0.8 + Math.random() * 0.4);
          this.shape.push({ 
            x: Math.cos(a) * rad, 
            y: Math.sin(a) * rad,
            highlight: Math.random() > 0.7
          });
        }
      }
      
      update() {
        this.z -= this.speed;
        this.angle += this.rotationSpeed;
        this.bobOffset += this.bobSpeed;
        if (this.z <= 0) this.reset();
      }
      
      draw(ctx) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        const f = 200 / this.z;
        const px = (this.x - w / 2) * f + w / 2;
        const py = (this.y - h / 2) * f + h / 2 + Math.sin(this.bobOffset) * 2;
        const scale = this.z > 0 ? f : 0;
        
        if (px < -100 || px > w + 100 || py < -100 || py > h + 100) return;
        
        const alpha = Math.max(0, Math.min(1, (w - this.z) / w));
        
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(this.angle);
        ctx.scale(scale, scale);
        
        // Draw main asteroid body with gradient
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 1.2);
        gradient.addColorStop(0, this.primaryColor + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
        gradient.addColorStop(0.7, this.secondaryColor + Math.floor(alpha * 180).toString(16).padStart(2, '0'));
        gradient.addColorStop(1, '#000000' + Math.floor(alpha * 100).toString(16).padStart(2, '0'));
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        ctx.lineWidth = 2;
        
        // Draw asteroid shape
        ctx.beginPath();
        this.shape.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Add cartoon-style highlights
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
        this.shape.forEach(pt => {
          if (pt.highlight) {
            ctx.beginPath();
            ctx.arc(pt.x * 0.7, pt.y * 0.7, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        // Add glow effect
        ctx.shadowColor = this.primaryColor;
        ctx.shadowBlur = 10 * scale;
        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
        ctx.beginPath();
        this.shape.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
    }

    class ShootingStar {
      constructor() { this.reset(); }
      reset() {
        const w = canvasFar.width;
        const h = canvasFar.height;
        if (Math.random() < 0.5) {
          this.x = Math.random() * w;
          this.y = -10;
        } else {
          this.x = w + 10;
          this.y = Math.random() * h;
        }
        this.len = 80 + Math.random() * 30;
        this.speed = 4 + Math.random() * 2;
        this.alpha = 1;
        const angle = Math.PI + Math.random() * 0.2 - 0.1;
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
      }
      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.alpha -= 0.01;
        if (this.alpha <= 0) this.reset();
      }
      draw(ctx) {
        if (this.alpha <= 0) return;
        ctx.save();
        ctx.strokeStyle = `rgba(255,255,255,${this.alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
          this.x + this.dx * this.len * 0.02,
          this.y + this.dy * this.len * 0.02
        );
        ctx.stroke();
        ctx.restore();
      }
    }

    function initScene() {
      const countFar = parseInt(
        getComputedStyle(document.documentElement).getPropertyValue('--star-count-far')
      );
      for (let i = 0; i < countFar; i++) starsFar.push(new Star(true));
      const countNear = parseInt(
        getComputedStyle(document.documentElement).getPropertyValue('--star-count-near')
      );
      for (let i = 0; i < countNear; i++) starsNear.push(new Star(false));
      const countAst = parseInt(
        getComputedStyle(document.documentElement).getPropertyValue('--asteroid-count')
      );
      for (let i = 0; i < countAst; i++) asteroids.push(new Asteroid());
    }

    function animateScene() {
      requestAnimationFrame(animateScene);
      drawFarStars();
      drawNearStars();
      drawAsteroids();
      drawShootingStars();
    }

    function drawFarStars() {
      const ctx = ctxFar;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;
      ctx.clearRect(0, 0, w, h);
      starsFar.forEach(star => {
        star.update();
        star.draw(ctx);
      });
    }

    function drawNearStars() {
      const ctx = ctxNear;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;
      ctx.clearRect(0, 0, w, h);
      starsNear.forEach(star => {
        star.update();
        star.draw(ctx);
      });
    }

    function drawAsteroids() {
      const ctx = ctxAst;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;
      ctx.clearRect(0, 0, w, h);
      asteroids.forEach(ast => {
        ast.update();
        ast.draw(ctx);
      });
    }

    function drawShootingStars() {
      const chance = parseFloat(
        getComputedStyle(document.documentElement).getPropertyValue('--shooting-star-chance')
      );
      if (Math.random() < chance) shootingStars.push(new ShootingStar());
      const ctx = ctxFar; // draw shooting stars on the far-canvas layer
      shootingStars.forEach((ss, i) => {
        ss.update();
        ss.draw(ctx);
      });
      shootingStars = shootingStars.filter(ss => ss.alpha > 0);
    }

    initScene();
    animateScene();

    document.addEventListener('DOMContentLoaded', () => {
      const layer = document.getElementById('stars-layer');
      const total = parseInt(
        getComputedStyle(document.documentElement).getPropertyValue('--parallax-star-count')
      );
      for (let i = 0; i < total; i++) {
        const star = document.createElement('div');
        star.className = 'star-parallax';
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        const z = (Math.random() * 1000) - 500;
        const rand = Math.random();
        const randAlpha = 0.5 + Math.random() * 0.5;
        star.style.setProperty('--x', `${x}%`);
        star.style.setProperty('--y', `${y}%`);
        star.style.setProperty('--z', `${z}px`);
        star.style.setProperty('--rand', rand);
        star.style.setProperty('--rand-alpha', randAlpha);
        layer.appendChild(star);
      }
    });

    const logoEl = document.querySelector('.logo');
    
    // Simplified mouse interaction for performance
    let mouseInteractionEnabled = true;
    
    // Throttle mouse events for better performance
    let mouseThrottle = false;
    document.addEventListener('mousemove', e => {
      if (mouseThrottle || !mouseInteractionEnabled) return;
      mouseThrottle = true;
      setTimeout(() => mouseThrottle = false, 16); // ~60fps
      
      const tx = e.clientX - window.innerWidth / 2;
      const ty = e.clientY - window.innerHeight / 2;
      const rotateY = (tx / window.innerWidth) * 15; // Reduced rotation
      const rotateX = -(ty / window.innerHeight) * 15;
      logoEl.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
    });
    
    document.addEventListener('mouseleave', () => {
      logoEl.style.transform = 'rotateX(0deg) rotateY(0deg)';
    });
    
    // Disable mouse interactions on mobile for performance
    if (window.innerWidth <= 768) {
      mouseInteractionEnabled = false;
      logoEl.style.transform = 'none';
    }
    
    // Re-check on resize
    window.addEventListener('resize', () => {
      if (window.innerWidth <= 768) {
        mouseInteractionEnabled = false;
        logoEl.style.transform = 'none';
      } else {
        mouseInteractionEnabled = true;
      }
    });

    // Interactive particles canvas with performance optimizations
    const particlesCanvas = document.getElementById('canvas-particles');
    const particlesCtx = particlesCanvas.getContext('2d');
    let particles = [];
    let animationId;
    let isVisible = true;
    
    // Performance settings based on device capabilities
    const isMobile = window.innerWidth <= 768;
    const particleSettings = {
      maxParticles: isMobile ? 8 : parseInt(
        getComputedStyle(document.documentElement).getPropertyValue('--particle-count')
      ),
      animationSpeed: isMobile ? 30 : 16, // Lower FPS on mobile
    };

    function resizeParticlesCanvas() {
      particlesCanvas.width = window.innerWidth;
      particlesCanvas.height = window.innerHeight;
    }
    
    window.addEventListener('resize', resizeParticlesCanvas);
    resizeParticlesCanvas();
    
    // Pause animation when tab is not visible for performance
    document.addEventListener('visibilitychange', () => {
      isVisible = !document.hidden;
      if (isVisible && !animationId) {
        animateParticles();
      } else if (!isVisible && animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    });

    class InteractiveParticle {
      constructor() {
        this.x = Math.random() * particlesCanvas.width;
        this.y = Math.random() * particlesCanvas.height;
        this.vx = (Math.random() - 0.5) * (isMobile ? 1 : 2);
        this.vy = (Math.random() - 0.5) * (isMobile ? 1 : 2);
        this.size = Math.random() * (isMobile ? 2 : 3) + 1;
        this.alpha = Math.random() * 0.5 + 0.3;
        this.color = this.getRandomColor();
        this.life = 1;
        this.decay = Math.random() * 0.003 + 0.001;
      }
      
      getRandomColor() {
        const colors = isMobile ? [
          '#FF6B9D', '#00D2FF', '#3742FA', '#2ED573'
        ] : [
          '#FF6B9D', '#C44569', '#F8B500', '#00D2FF', 
          '#3742FA', '#2ED573', '#FF3838', '#FF9F43',
          '#A855F7', '#06B6D4', '#F472B6', '#FBBF24',
          '#34D399', '#FB923C', '#F87171', '#FDE047'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        
        // Wrap around screen
        if (this.x < 0) this.x = particlesCanvas.width;
        if (this.x > particlesCanvas.width) this.x = 0;
        if (this.y < 0) this.y = particlesCanvas.height;
        if (this.y > particlesCanvas.height) this.y = 0;
        
        return this.life > 0;
      }
      
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha * this.life;
        
        // Simplified rendering for mobile
        if (isMobile) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Enhanced rendering for desktop
          ctx.fillStyle = this.color;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.lineWidth = 1;
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 10;
          
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Add inner glow
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < particleSettings.maxParticles; i++) {
        particles.push(new InteractiveParticle());
      }
    }

    let lastTime = 0;
    function animateParticles(currentTime = 0) {
      if (!isVisible) return;
      
      // Throttle animation based on device capability
      if (currentTime - lastTime < particleSettings.animationSpeed) {
        animationId = requestAnimationFrame(animateParticles);
        return;
      }
      lastTime = currentTime;
      
      particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
      
      particles = particles.filter(particle => {
        const alive = particle.update();
        if (alive) {
          particle.draw(particlesCtx);
        }
        return alive;
      });
      
      // Add new particles to maintain count
      while (particles.length < particleSettings.maxParticles) {
        particles.push(new InteractiveParticle());
      }
      
      animationId = requestAnimationFrame(animateParticles);
    }

    initParticles();
    animateParticles();
    
    // Adjust particles on resize
    window.addEventListener('resize', () => {
      const wasMobile = particleSettings.maxParticles <= 8;
      const nowMobile = window.innerWidth <= 768;
      
      if (wasMobile !== nowMobile) {
        particleSettings.maxParticles = nowMobile ? 8 : parseInt(
          getComputedStyle(document.documentElement).getPropertyValue('--particle-count')
        );
        particleSettings.animationSpeed = nowMobile ? 30 : 16;
        initParticles(); // Reinitialize with new settings
      }
    });

    // Simple logo click effect without energy pulses
    logoEl.addEventListener('click', () => {
      // Simple scale animation for feedback
      logoEl.style.transform = 'scale(1.1)';
      setTimeout(() => {
        logoEl.style.transform = '';
      }, 200);
    });
  </script>
</body>
</html>
